#!/bin/bash

# Qencode 08/26/12 #######################################################
##									##
## This script is used to make hifi DVD rips including chapter markers 	##
## and subtitles, using Handbrake for encoding.                      	##
## Contains what I found to be the best quality ripping parameters and 	##
## also lets me set simple parameters I need.                          	##
##                                                                     	##
## Qencode is used in concert with Qripdvd and Qmanager to fully 	##
## automate DVD ripping and encoding.					##
##									##
## Requires HandbrakeCLI.		                                ##
##									##
## Adam Jenkins								##
## Updated by Steven Mirabito						##
##                                                                     	##
## $Id$                                                                	##
##########################################################################

#set -x

DESTINATION=${DESTINATION:=/var/hda/files/Movies}
## Directory for finished file(s)

HANDBRAKE=${HANDBRAKE:=/usr/bin/HandBrakeCLI}
## Where is the Handrake encoder executable.

CLEAN=${CLEAN:="yes"}
## Clean up work files when done.

VERBOSE=${VERBOSE:="no"}
## Be verbose while processing.

CHAPTERS=${CHAPTERS:=0}
## Chapters to encode. Example: 0 or undefined (all chapters), 7 (only chapter 7), 3-6 (chapters 3 to 6)

PLAYALL=${PLAYALL:="no"}
## Encode a series disc "Play All" track instead of indivudual episodes.

SUBS=${SUBS:="yes"}
## Grab subtitles.

TWOPASS=${TWOPASS:="yes"}
## Do two-pass encoding.

QUALITY=${QUALITY:=0.600000023841858}
## Target quality. RF 20

USER=root
GROUP=users
## User and Group to set file ownership

X264ARGS="b-adapt=2:rc-lookahead=50"    # HIGH PROFILE
## Define args for the x264 encoder.

MATRIX=${MATRIX:=%AMAHIRIP_DIR%/lib/eqm_v3ulr_rev3.xcm}
## x264 matrix to use. The matrix file may increase encoding speed and quality.
## This one is Sharktooth's as found at http://forum.doom9.org/showthread.php?t=96298

range=1.15
## Percentage range to determine episode titles on a series disc

shortrange=1.1
## Percentage range to determine play-all title on a series disc

longrange=1.6
## Percentage range to determine premiere episode on a series disc

longerthan=0; export longerthan
## To include tracks longer than specified time (in seconds)

shorterthan=28800; export shorterthan
## To include tracks shorter than specified time (in seconds)


################# DO NOT CHANGE ANYTHING BELOW THIS LINE #################
########################### unless you want to ###########################

## Dumpout if no queue file argument is provided.
if [ -z $1 ]; then
        echo "Path to queue file not given. Queue file generated by Qripdvd."
        echo "Usage: Qencode \"/tmp/dvdrip/queue/FILENAME.queue\""
        exit
fi

## Get encoding variables from queue file.
. $1

##########################################################################
## Gather data about the ripped DVD's titles and their duration and use	##
## that data to evaluate the disc for content format:			##
##									##
##   Regular Series, Series with Play-All Option, Series with long	##
##   Premiere Episode, Regular Movie or Movie with enhanced features.	##
##                                                                 	##
## This is all very experimental and not likely to work with all discs,	##
## but it should make bulk ripping easier in the long run.		##
##########################################################################

echo " "
echo "____________________"
echo "|: DVD EVALUATION :|"
echo "===================================================="
echo "DVD DISC TITLE => ${DISCTITLE}"
echo "===================================================="

## Get title lengths (in seconds) from DVD and place in array TITLES
TITLES=($(HandBrakeCLI -t 0 -i ${INPUT} --main-feature 2>&1 | grep "has length" | sed 's/sec//' | gawk '$8 >= (ENVIRON["longerthan"]) && $8 <= (ENVIRON["shorterthan"]) {print $8}'))
len=${#TITLES[*]}       # len is the total list of titles on the disc

## Get title size and aspect ratio
ASPECT=($(HandBrakeCLI -t 0 -i ${INPUT} --main-feature 2>&1 | grep "aspect" | grep "previews" | sed 's/[(),]//g' | gawk '{print $5"-"$12}'))
# Variable value [number] corresponds to DVD title number

## Get title languages & encodings
LANG0=($(HandBrakeCLI -t 0 -i ${INPUT} --main-feature 2>&1 | grep "scan: audio 0x80bd" | grep "bitrate" | sed "s/[(),']//g" | gawk '{print $8"-"$9"-"$10}'))
        # Get language, encoding & format for audio track 1
LANG1=($(HandBrakeCLI -t 0 -i ${INPUT} --main-feature 2>&1 | grep "scan: audio 0x81bd" | grep "bitrate" | sed "s/[(),']//g" | gawk '{print $8"-"$9"-"$10}'))
        # Get language, encoding & format for audio track 2
LANG2=($(HandBrakeCLI -t 0 -i ${INPUT} --main-feature 2>&1 | grep "scan: audio 0x82bd" | grep "bitrate" | sed "s/[(),']//g" | gawk '{print $8"-"$9"-"$10}'))
        # Get language, encoding & format for audio track 3
# Variable value [number] corresponds to DVD title number

## Determine longest title
MAX=0
i=0
while [ $i -lt $len ]; do
        val=`echo "${TITLES[$i]}" `
        if [ $(echo "$MAX < $val" | bc) -eq 1 ]; then
                MAX=$val
                MAXTITLE=$i # Variable value [number] corresponds to DVD title number
        fi
        let i++
done

## Determine second-longest title
SECOND=0
i=0
while [ $i -lt $len ] && [ $len -ne 1 ]; do
        val=`echo "${TITLES[$i]}" `
        if [ $(echo "$SECOND < $val" | bc) -eq 1 ] && [ "$i" -ne "$MAXTITLE" ]; then
                SECOND=$val
                SECTITLE=$i # Variable value [number] corresponds to DVD title number
        fi
        let i++
done

## Determine third-longest title
THIRD=0
i=0
while [ $i -lt $len ] && [ $len -ne 1 ]; do
        val=`echo "${TITLES[$i]}" `
        if [ $(echo "$THIRD < $val" | bc) -eq 1 ] && [ "$i" -ne "$MAXTITLE" ] && [ "$i" -ne "$SECTITLE" ]; then
                THIRD=$val
                THRTITLE=$i # Variable value [number] corresponds to DVD title number
        fi
        let i++
done

## Determine all titles with duration within x% range of second-longest title
declare -a RANGETITLES
declare -a RANGETIMES
LAST=0
i=0
while [ $i -lt $len ] && [ $len -ne 1 ]; do
        val=`echo "${TITLES[$i]}" `
        if [ $(echo "(($val*0.01)*$range+1) >= ($SECOND*0.01)" | bc) -eq 1 ] && [ "$i" -ne "$MAXTITLE" ] || [ $(echo "(($val*0.01)*$range-1) >= ($SECOND*0.01)" | bc) -eq 1 ] && [ "$i" -ne "$MAXTITLE" ]; then
                # Move the decimal point for title durations left by two and add +/- 1 variation to range.
                LAST=$i
                RANGETITLES[$i]=$i      # Array value(s) correspond to DVD title numbers
                RANGETIMES[$i]=$val     # Array value(s) correspond to DVD title times
        fi
        let i++
done

## Determine all SEQUENTIAL title durations within x% range of third-longest title
declare -a sRANGETITLES
declare -a sRANGETIMES
i=0
while [ $i -lt $len ] && [ $len -ne 1 ]; do
        val=`echo "${TITLES[$i]}" `
	if [ "${LANG0[$i]}" == "${LANG0[$THRTITLE]}" ] && [ "$i" -ne "$MAXTITLE" ] && [ $(echo "(($val*0.01)*$range+1) >= ($THIRD*0.01)" | bc) -eq 1 ] || [ "${LANG0[$i]}" == "${LANG0[$THRTITLE]}" ] && [ "$i" -ne "$MAXTITLE" ] && [ $(echo "(($val*0.01)*$range-1) >= ($THIRD*0.01)" | bc) -eq 1 ]; then
                # Move the decimal point for title durations left by two and add +/- 1 variation to range.
                sRANGETITLES[$i]=$i      # Array value(s) correspond to DVD title numbers
                sRANGETIMES[$i]=$val     # Array value(s) correspond to DVD title times
        elif [ ${#sRANGETITLES[*]} -ge 2 ]; then
                break
        elif [ ${#sRANGETITLES[*]} -eq 1 ]; then
                sRANGETITLES=()
                sRANGETIMES=()
                break
        fi
        let i++
done

## Get sum of rangetimes array
RANGESUM=0
for i in ${RANGETITLES[*]}; do
        RANGESUM=$(echo "${RANGESUM} + ${RANGETIMES[$i]}" | bc)
done

## Get sum of SEQUENTIAL rangetimes array
sRANGESUM=0
for i in ${sRANGETITLES[*]}; do
        sRANGESUM=$(echo "${sRANGESUM} + ${sRANGETIMES[$i]}" | bc)
done

## Get average of rangetimes
RANGEAVE="0"
[[ $len -ne 1 ]] && RANGEAVE=$(echo "${RANGESUM}/${#RANGETITLES[*]}" | bc)

##################################################################################
## Echo what we've learned about the DVD                                        ##
##################################################################################

i=0
echo "TITLE	TIME	LANGUAGE/FORMAT		ASPECT RATIO"
echo "----------------------------------------------------"
while [ $i -lt $len ] && [ $len -ne 0 ]; do
        if [ -n "${LANG0[$i]}" ]; then
                echo "$i:	${TITLES[$i]}	${LANG0[$i]}	${ASPECT[$i]}"
        else
                echo "$i:	${TITLES[$i]}	[ NOT DEFINED ]   	${ASPECT[$i]}"
        fi
        [[ -n "${LANG1[$i]}" ]] && echo "		${LANG1[$i]}"
        [[ -n "${LANG2[$i]}" ]] && echo "		${LANG2[$i]}"
        let i++
done
echo "===================================================="
echo "MAX TITLE	${MAXTITLE}"
echo "MAX TITLE TIME	$MAX"
[[ ! -z $SECTITLE ]] && echo "2nd TITLE	${SECTITLE}"
[[ $SECOND > 0 ]] && echo "2nd TITLE TIME	$SECOND"
[[ ! -z $THRTITLE ]] && echo "3rd TITLE	${THRTITLE}"
[[ $THIRD > 0 ]] && echo "3rd TITLE TIME	$THIRD"
[[ ! -z ${RANGETITLES[*]} ]] && echo "RANGE TITLES	${RANGETITLES[*]}"
[[ ! -z ${RANGETIMES[*]} ]] && echo "RANGE TIMES	${RANGETIMES[*]}"
[[ $RANGESUM > 0 ]] && echo "RANGE SUM	${RANGESUM}"
[[ $RANGEAVE > 0 ]] && echo "RANGE AVERAGE	$RANGEAVE"
[[ ! -z ${sRANGETITLES[*]} ]] && echo "SQ RANGE TITLES	${sRANGETITLES[*]}"
[[ $sRANGESUM > 0 ]] && echo "SQ RANGE SUM	${sRANGESUM}"

##################################################################################
## Evaluate information we've gathered and use it to divine disc contents.	##
## Yes, it is Voodoo. No, it doesn't always work.                               ##
##################################################################################

## For a movie disc with an "enhanced features" title containing special graphics (that we don't want).
## We assume the regular and "enhanced" versions are the same length, longer than a series episode, sequential and only two in quanity.
if [ $MAX -eq $SECOND ] && [ $MAX -ge 4000 ] && [ $(echo "($MAXTITLE+1) == $SECTITLE" | bc) -eq 1 ] && [ ${#RANGETITLES[*]} -lt 3 ]; then
        TYPE=${TYPE:=L}
        RIPTITLE=${TITLE:=L}
        echo "====================="
        echo "DVD is a movie disc with special feature title."
        echo "Rip first, longest title => ${MAXTITLE}"
        echo " "

## For a regular series disc, the range titles should have like durations and be at least two in quantity.
elif [ $len -ne 1 ] && [ $(echo "($SECOND*$range) >= $MAX" | bc) -eq 1 ]; then
        TYPE=${TYPE:=S}
        RIPTITLE=( $(echo "${MAXTITLE} ${RANGETITLES[*]}" | tr " " "\n" | sort -g | tr "\n" " " ) )
        echo "====================="
        echo "DVD is regular series disc."
        echo "RIPTITLES => ${RIPTITLE[*]}"
        echo " "

## For series disc with a consolidated play-all title, max title should be approximately same duration as the sum of range titles.
elif [ $len -ne 1 ] && [ $(echo "($RANGESUM*$shortrange) >= $MAX" | bc) -eq 1 ] && [ $(echo "($MAX*$shortrange) >= $RANGESUM" | bc) -eq 1 ]; then
        TYPE=${TYPE:=PA}
       	RIPTITLE=( $(echo "${RANGETITLES[*]}" | tr " " "\n" | sort -g | tr "\n" " " ) )
        echo "====================="
        echo "DVD is series disc with play-all title."
        echo "RIPTITLES => ${RIPTITLE[*]}"
        echo " "

## For series disc with a consolidated play-all title, max title should be approximately same duration as the sum of SEQUENTIAL range titles.
elif [ $len -ne 1 ] && [ $(echo "($sRANGESUM*$shortrange) >= $MAX" | bc) -eq 1 ] && [ $(echo "($MAX*$shortrange) >= $sRANGESUM" | bc) -eq 1 ]; then
        TYPE=${TYPE:=PA}
        RIPTITLE=( $(echo "${sRANGETITLES[*]}" | tr " " "\n" | sort -g | tr "\n" " " ) )
        echo "====================="
        echo "DVD is series disc with play-all title."
        echo "RIPTITLES => ${RIPTITLE[*]}"
        echo " "

## For series disc with extra-long first episode (premiere), longest title duration isn't greater than x% of range titles
elif [ $len -ne 1 ] && [ $(echo "($RANGEAVE*$longrange) >= $MAX" | bc) -eq 1 ]; then
        TYPE=${TYPE:=S}
        RIPTITLE=( $(echo "${MAXTITLE} ${RANGETITLES[*]}" | tr " " "\n" | sort -g | tr "\n" " " ) )
        echo "====================="
        echo "DVD is series premiere disc."
        echo "RIPTITLES => ${RIPTITLE[*]}"
        echo " "

## The only option left is a regular movie disc
else
        TYPE=${TYPE:=L}
        RIPTITLE=${TITLE:=L}
        echo "====================="
        echo "DVD is a movie disc."
        echo "Rip longest title => ${MAXTITLE}"
        echo " "
fi

## For a series disc, make a folder for the files and update $DESTINATION path.
if [[ $TYPE = "S" || $TYPE = "PA" ]]; then
        DESTINATION+=/${DISCTITLE}
        if [ -e "$DESTINATION" ]; then
                DESTINATION+=_${TIMESTAMP}
        fi
        mkdir $DESTINATION
        chown $USER:$GROUP $DESTINATION
fi

##########################################################################
## Begin encoding loop, hold onto your butts... 			##
##########################################################################

for (( i = 0 ; i < ${#RIPTITLE[*]} ; i++ )); do			# Array $TITLE contains titles to encode, 
								# the number of which dictates loops
	if [ $TYPE = "S" ]; then      # Series disc
                TITLE=$(echo "${RIPTITLE[$i]} + 1" | bc)
		TITLENUM="_e"$[$i+1]
		echo "Encoding Series Disc - Type S"
	elif [ $TYPE = "PA" ] && [ $PLAYALL != "yes" ]; then	# Series disc with "Play All" title
                TITLE=$(echo "${RIPTITLE[$i]} + 1" | bc)	# Encodes individual episodes
                TITLENUM="_e"$[$i+1]
		echo "Encoding Series Disc - Type PA"
	else 			        			# Movie disc or series "Play All" title
		TITLENUM=""					# Encodes movie or "Play All" title
		echo "Encoding Movie Disc - Type L"
	fi
        ## The title number(s) to rip, or "L" to get the longest title

        FILENAME=$WORKPATH/$DISCTITLE$TITLENUM.mkv
        ## Define output filename path.

## Subtitles parameters.
	if [ $SUBS = "yes" ]; then
                SUBTITLES=${SUBTITLES:="-s scan -N eng -F --subtitle-burn"} 	# GRABS ENGLISH SUBS, SHOULD BURN FORCED VOBSUB BUT DOES NOT
#		SUBTITLES=${SUBTITLES:="-s 1,2,3,4 -N eng -F --subtitle-burn"}	# GRABS FIRST 4 SUBS, SHOULD BURN FORCED VOBSUB BUT DOES NOT
	else										# POSSIBLY BUG IN HANDBRAKE 0.9.4
		SUBTITLES=${SUBTITLES:=""}
	fi

## Audio parameters.     
        if [ $TYPE = "L" ]; then ATITLE=$MAXTITLE; else ATITLE=$TITLE; fi
        LANGUAGE0=$(echo ${LANG0[${ATITLE}]} | sed 's/-/ /' | gawk '{print $1}')
        LANGUAGE1=$(echo ${LANG1[${ATITLE}]} | sed 's/-/ /' | gawk '{print $1}')
        LANGUAGE2=$(echo ${LANG2[${ATITLE}]} | sed 's/-/ /' | gawk '{print $1}')

#       AUDIO=${AUDIO:="-E ac3 -6 dpl2 -D 1"}                                   # FOR SIMPLE AC3 PASSTHRU (copy).
        AUDIO=${AUDIO:="-E ac3,faac -B auto,192 -R auto,48 -6 auto,dpl2 -A $LANGUAGE0,$LANGUAGE0-Stereo"}
        									# PRODUCES AC3 PASSTHRU ON TRACK 1, AAC STEREO MIXDOWN ON TRACK 2.
	## FOR FOREIGN LANGUAGE DISC, GRABS MAIN TRACK AND ENGLISH TRACK (if available)
        if [ $(echo ${LANG0[${ATITLE}]} | sed 's/-/ /' | gawk '{print $1}') != "English" ]; then
                echo "Foriegn language title detected."
                if [ $(echo ${LANG1[${ATITLE}]} | sed 's/-/ /' | gawk '{print $1}') = "English" ]; then
                        echo "English language track detected on channel 2."
                        AUDIO="-a 1,1,2,2 -E ac3,faac,ac3,faac -B auto,192,auto,192 -R auto,48,auto,48 -6 auto,dpl2,auto,dpl2 -A $LANGUAGE0,$LANGUAGE0-Stereo,$LANGUAGE1,$LANGUAGE1-Stereo"
                                                                                # AC3 PASSTHRU ON TRACKS 1+3, AAC STEREO MIXDOWN ON TRACKS 2+4.
                elif [ $(echo ${LANG2[${ATITLE}]} | sed 's/-/ /' | gawk '{print $1}') = "English" ]; then
                        echo "English language track detected on channel 3."
                        AUDIO="-a 1,1,3,3 -E ac3,faac,ac3,faac -B auto,192,auto,192 -R auto,48,auto,48 -6 auto,dpl2,auto,dpl2 -A $LANGUAGE0,$LANGUAGE0-Stereo,$LANGUAGE2,$LANGUAGE2-Stereo"
                                                                                # AC3 PASSTHRU ON TRACKS 1+3, AAC STEREO MIXDOWN ON TRACKS 2+4.
                fi
        fi

## Make some calculations regarding title and chapters based on parameters.
	SEGMENT=""
	if [[ "$TITLE" == "L" || -z "$TITLE" ]]; then
		SEGMENT="--main-feature"
	else
		SEGMENT="-t $TITLE"
	fi
	[[ -n "$CHAPTERS" && "$CHAPTERS" -ne 0 ]] && SEGMENT+=" -c $CHAPTERS"

## Other miscellaneous settings.
	[[ "$VERBOSE" != "no" ]] && VERB="-v"
        [[ "$TWOPASS" != "no" ]] && PASSES="-2"
	[[ -n "$MATRIX" ]] && X264ARGS+=":cqm=$MATRIX"

## Encode String...
	"$HANDBRAKE" $VERB -i $INPUT -o $FILENAME $SUBTITLES -e x264 -q $QUALITY $AUDIO -f mkv $PASSES -T -m $SEGMENT -x $X264ARGS -5
	
## Repackage to optimize file size, to include seek and to include this script as a way to document the rip...
	echo $FILENAME | grep -qi ".mkv"
	if [[ $? && -x `which mkvmerge` && -f $FILENAME ]]; then
		mv $FILENAME $FILENAME.mkv
		mkvmerge -o $FILENAME $FILENAME.mkv \
			--attachment-name "The ripping script" \
			--attachment-description "How this movie was created from original DVD" \
			--attachment-mime-type application/x-sh \
			--attach-file $0
		[[ -f $FILENAME ]] && rm $FILENAME.mkv
	fi
	
## Move finished file to archive, fix permissions, clean filename, fix capitalization.
	CLEANNAME=$(echo ${DISCTITLE}${TITLENUM}|sed 's/_/ /g; s/.*/\L&/; s/[a-z]*/\u&/g') # use on names wihout suffix
	## Clean output filename for underscores and capitalization.

        if [ -e "$DESTINATION/$CLEANNAME.mkv" ]; then
                CLEANNAME=${CLEANNAME}"_"${TIMESTAMP}
                echo "Filename exists, adding timestamp to new filename."
	fi
	## Check if file with same name exists in target folder, add timestamp if true.

	mv "$FILENAME" "$DESTINATION/$CLEANNAME.mkv"
	chown -f $USER:$GROUP "$DESTINATION/$CLEANNAME.mkv"
	## Move file, set ownership
done

## Clean-up work path
[[ "$CLEAN" != "no" ]] && rm -rf $WORKPATH

exit
